/**
 * Copyright - xWhitey ~ ScriptedSnark, 2022.
 * patterns.hpp - Our pattern-system
 */

#ifdef PATTERNS_HPP_RECURSE_GUARD
#error Recursive header files inclusion detected in patterns.hpp
#else //PATTERNS_HPP_RECURSE_GUARD

#define PATTERNS_HPP_RECURSE_GUARD

#ifndef PATTERNS_HPP_GUARD
#define PATTERNS_HPP_GUARD
#pragma once

#include "MemUtils.hpp"

typedef unsigned char uint8_t;

std::vector<std::string> split(const std::string& s, char seperator) {
	std::vector<std::string> output;

	int prev_pos = 0, pos = 0;

	while ((pos = s.find(seperator, pos)) != std::string::npos) {
		std::string substring(s.substr(prev_pos, pos - prev_pos));

		output.push_back(substring);

		prev_pos = ++pos;
	}

	output.push_back(s.substr(prev_pos, pos - prev_pos));

	return output;
}

uint8_t hex(char c) {
	return (c >= '0' && c <= '9') ? static_cast<uint8_t>(c - '0')
		: (c >= 'a' && c <= 'f') ? static_cast<uint8_t>(c - 'a' + 10)
		: (c >= 'A' && c <= 'F') ? static_cast<uint8_t>(c - 'A' + 10)
		: throw std::domain_error("not a hex digit");
}

typedef struct CIntelligentPattern {
	explicit CIntelligentPattern(std::string peidPattern, std::string version) {
		std::vector<uint8_t> pattern = {};
		std::string mask = "";
		std::map<std::vector<uint8_t>, std::string> _pattern;
		auto splitten = split(peidPattern, ' ');
		for (unsigned int idx = 0; idx < splitten.size(); idx++) {
			if (splitten[idx] == "??") {
				mask.append("?");
				pattern.push_back(0xCC);
			}
			else {
				mask.append("x");
				pattern.push_back(hex(splitten[idx][0]) * 16 + hex(splitten[idx][1]));
			}
		}
		_pattern.insert(std::make_pair(pattern, mask));
		std::map<decltype(_pattern), std::string> final_pattern;
		final_pattern.insert(std::make_pair(_pattern, version));
		patterns.push_back(final_pattern);
	}
	explicit CIntelligentPattern(std::vector<std::string> peidPatterns, std::vector<std::string> versions) {
		for (unsigned int idx = 0; idx < peidPatterns.size(); idx++) {
			auto peidPattern = peidPatterns.at(idx);
			auto version = versions.at(idx);
			std::vector<uint8_t> pattern = {};
			std::string mask = "";
			std::map<std::vector<uint8_t>, std::string> _pattern;
			auto splitten = split(peidPattern, ' ');
			for (unsigned int idx = 0; idx < splitten.size(); idx++) {
				if (splitten[idx] == "??") {
					mask.append("?");
					pattern.push_back(0xCC);
				}
				else {
					mask.append("x");
					pattern.push_back(hex(splitten[idx][0]) * 16 + hex(splitten[idx][1]));
				}
			}
			_pattern.insert(std::make_pair(pattern, mask));
			std::map<decltype(_pattern), std::string> final_pattern;
			final_pattern.insert(std::make_pair(_pattern, version));
			patterns.push_back(final_pattern);
		}
	}
	explicit CIntelligentPattern(std::vector<uint8_t> pattern, std::string mask, std::string version) {
		patterns = {}; //making patterns empty in case of nullptr
		std::map<std::vector<uint8_t>, std::string> _pattern;
		//bytes, mask
		_pattern.insert(std::make_pair(pattern, mask));
		std::map<decltype(_pattern), std::string> final_pattern;
		final_pattern.insert(std::make_pair(_pattern, version));
		patterns.push_back(final_pattern);

	}
	explicit CIntelligentPattern(std::vector<std::vector<uint8_t>> patterns, std::vector<std::string> masks, std::vector<std::string> versions) {
		this->patterns = {};
		for (unsigned int idx = 0; idx < patterns.size(); idx++) {
			std::map<std::vector<uint8_t>, std::string> pattern;
			//bytes, mask
			pattern.insert(std::make_pair(patterns[idx], masks[idx]));
			std::map<decltype(pattern), std::string> final_pattern;
			final_pattern.insert(std::make_pair(pattern, versions[idx]));
			this->patterns.push_back(final_pattern);
		}
	}
	std::vector<std::map<std::map<std::vector<uint8_t>, std::string>, std::string>> patterns;
	//vector<map<map<pattern, mask>, version>
} CIntelligentPattern;

/**
 * @author: xWhitey
 * @comment: _Module can't be nullptr!
 */
template<class ResultType> bool FindAsync(_In_ void* _Module, _In_ std::vector<uint8_t> _Pattern, _In_ const char* _Mask, _Out_ ResultType& _Result) {
	if (!_Module) return false;
	if (!_Mask[0] || !_Mask) return false;

	auto module_size = MemUtils::GetModuleSize(_Module);

	unsigned int pattern_length = strlen(_Mask);
	unsigned char* based = reinterpret_cast<unsigned char*>(_Module);

	for (unsigned int idx = 0; idx < module_size - pattern_length; ++idx) {
		bool found = true;
		for (unsigned int i = 0; i < pattern_length; i++) {
			if (_Mask[i] != '?' && based[idx + i] != _Pattern[i]) {
				found = false;
				break;
			}
		}

		if (found) {
			_Result = ((ResultType)&based[idx]);

			return true;
		}
	}

	return false;
}

template<class ResultType> void FindAsync(_In_ void* _Module, _In_ CIntelligentPattern* _Pattern, _Out_ ResultType& _Result, _In_ std::function<void(std::string)> _ToDoUponFound, _In_ std::function<void()> _ToDoIfCouldntFind) {
	bool found = false;
	for (auto p : _Pattern->patterns) {
		for (auto val : p) {
			auto pattern = val.first;
			auto version = val.second;
			for (auto m : pattern) {
				auto bytes = m.first;
				auto mask = m.second;
				if (found = FindAsync(_Module, bytes, mask.c_str(), _Result)) {
					_ToDoUponFound(version);
					return;
				}
			}
		}
	}
	if (!found) _ToDoIfCouldntFind();
}

template<class ResultType> bool FindAsync(_In_ void* _Module, _In_ CIntelligentPattern* _Pattern, _Out_ ResultType& _Result) {
	for (auto p : _Pattern->patterns) {
		for (auto val : p) {
			auto pattern = val.first;
			auto version = val.second;
			for (auto m : pattern) {
				auto bytes = m.first;
				auto mask = m.second;
				return FindAsync(_Module, bytes, mask.c_str(), _Result);
			}
		}
	}
}

/**
 * Warning! You must follow this example in case of creating custom pattern: pattern1, pattern2, mask1, mask2, version1, version2
 * Otherwise you'll break the whole pattern-system!
 */
namespace patterns {
	namespace engine {
		const auto Cbuf_AddText = new CIntelligentPattern({
			//Sven-5.25
			{ 0x56, 0x8B, 0x74, 0x24, 0xCC, 0x56, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0x03, 0x05, 0xCC, 0xCC, 0xCC, 0xCC, 0x83, 
				0xC4, 0x04, 0x3B, 0x05, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0xCC, 0x5E, 0xC7, 0x44, 0x24, 0x04, 0x68, 0x34 },
			//HL-SteamPipe-8183
			{ 0x55, 0x8B, 0xEC, 0x8B, 0x45, 0x08, 0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0x50, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC,
				0x83, 0xC4, 0x08, 0x5D, 0xC3, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x55, 0x8B, 0xEC, 0x56, 0x57, 0x8B, 0x7D, 0x08, 0x57, 0xE8 },
			//HL-SteamPipe
			{ 0x55, 0x8B, 0xEC, 0x56, 0x8B, 0x75, 0x08, 0x56, 0xE8, 0xCC, 0xCC, 0xCC, 
				0xCC, 0x8B, 0x0D, 0xCC, 0xCC, 0xCC, 0xCC, 0x83, 0xC4, 0x04, 0x03, 0xC8, 0xA1, 0xCC, 0xCC, 0xCC, 0xCC, 0x3B, 0xC8, 0x7C, 0x10, 0x68 },
			//HL-NGHL
			{ 0x56, 0x8B, 0x74, 0x24, 0x08, 0x56, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0x0D, 0xCC, 0xCC, 0xCC, 0xCC, 0x83, 
				0xC4, 0x04, 0x03, 0xC8, 0xA1, 0xCC, 0xCC, 0xCC, 0xCC, 0x3B, 0xC8, 0x7C },
			//HL-WON
			{ 0x56, 0x8B, 0x74, 0x24, 0x08, 0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0x56, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0x83, 0xC4, 0x08, 0x85, 
				0xC0, 0x75, 0x07, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0x5E, 0xC3, 0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0x56, 0xE8 }
			}, {
				//Sven-5.25
				"xxxx?xx????xx????xxxxx????x?xxxxxxx",
				//HL-SteamPipe-8183
				"xxxxxxx????xx????xxxxxxxxxxxxxxxxxxxxxxxxx",
				//HL-SteamPipe
				"xxxxxxxxx????xx????xxxxxx????xxxxx",
				//HL-NGHL
				"xxxxxxx????xx????xxxxxx????xxx", 
				//HL-WON
				"xxxxxx????xx????xxxxxxxx????xxx????xx"}, {"Sven-5.25", "HL-SteamPipe-8183", "HL-SteamPipe", "HL-NGHL", "HL-WON"});
		const auto Cbuf_InsertText = new CIntelligentPattern({ 0x53, 0x8B, 0x5C, 0x24, 0xCC, 0x56, 0x8B, 0x35, 0xCC, 0xCC, 0xCC, 0xCC, 0x53, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0x03, 0xC6 }, "xxxx?xxx????xx????xx", "Sven-5.25");
		const auto ClientDLL_Init = new CIntelligentPattern({ 0x81, 0xEC, 0x04, 0x02, 0x00, 0x00, 0xA1, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0xC4, 0x89, 0x84, 0x24, 0xCC, 0xCC, 0xCC, 0xCC, 0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0x8D, 0x44, 0x24, 0xCC, 0x68, 0x00, 0x02, 0x00, 0x00 }, "xxxxxxx????xxxxx????x????xxx?xxxxx", "Sven-5.25");
		const auto ClientDLL_CheckStudioInterface = new CIntelligentPattern({ 0xA1, 0xCC, 0xCC, 0xCC, 0xCC, 0x85, 0xC0, 0x75, 0xCC, 0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xA1 }, "x????xxx?x????x????x", "Sven-5.25");
		const auto Cmd_AddMallocCommand = new CIntelligentPattern({ 0x57, 0x8B, 0x7C, 0x24, 0xCC, 0x57, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0x83, 0xC4, 0x04, 0x80, 0x38, 0x00, 0x74, 0xCC, 0x57, 0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0x83, 0xC4, 0x08, 0x5F, 0xC3 }, "xxxx?xx????xxxxxxx?xx????x????xxxxx", "Sven-5.25");
		const auto Host_AutoSave_f = new CIntelligentPattern({ 0x83, 0x3D, 0xCC, 0xCC, 0xCC, 0xCC, 0x01, 0x0F, 0x85, 0xCC, 0xCC, 0xCC, 0xCC, 0x83, 0x3D, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, 0x75, 0xCC, 0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0x83, 0xC4, 0x04, 0x33, 0xC0 }, "xx????xxx????xx????xx?x????x????xxxxx", "Sven-5.25");
		const auto Host_Tell_f = new CIntelligentPattern({ 0x83, 0xEC, 0x44, 0xA1, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0xC4, 0x89, 0x44, 0x24, 0xCC, 0x83, 0x3D, 0xCC, 0xCC, 0xCC, 0xCC, 0x01 }, "xxxx????xxxxx?xx????x", "Sven-5.25");
		const auto Cvar_FindVar = new CIntelligentPattern({ 0x56, 0x57, 0x8B, 0x7C, 0x24, 0xCC, 0x85, 0xFF, 0x74, 0xCC, 0x80, 0x3F, 0x00, 0x74, 0xCC, 0x8B, 0x35, 0xCC, 0xCC, 0xCC, 0xCC, 0x85, 0xF6, 0x74, 0xCC, 0x8D, 0xA4, 0x24, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x36, 0x57, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0x83, 0xC4, 0x08, 0x85, 0xC0, 0x74, 0xCC, 0x8B, 0x76, 0xCC, 0x85, 0xF6, 0x75, 0xCC, 0x5F, 0x33, 0xC0, 0x5E, 0xC3, 0x5F }, "xxxxx?xxx?xxxx?xx????xxx?xxxxxxxxxxx????xxxxxx?xx?xxx?xxxxxx", "Sven-5.25");
		const auto Cvar_RegisterVariable = new CIntelligentPattern({ 0x83, 0xEC, 0x14, 0x53, 0x56, 0x57, 0x8B, 0x7C, 0x24 }, "xxxxxxxxx", "Sven-5.25");
		const auto Netchan_Transmit = new CIntelligentPattern({ 0xB8, 0x40, 0x01, 0x01, 0x00, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xA1, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0xC4, 0x89, 0x84, 0x24, 0x3C, 0x01, 0x01, 0x00, 0x8B, 0x84, 0x24, 0x4C, 0x01, 0x01, 0x00 }, "xxxxxx????x????xxxxxxxxxxxxxxxx", "Sven-5.25");
		const auto NET_DrawString = new CIntelligentPattern({ 0x8D, 0x44, 0x24, 0xCC, 0x50, 0x6A, 0x00, 0xFF, 0x74, 0x24, 0xCC, 0x68, 0x00, 0x04, 0x00, 0x00, 0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0x08, 0xFF, 0x70, 0xCC, 0x83, 0xC9, 0x01, 0x51, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0x83, 0xC4, 0x1C, 0x80, 0x3D, 0xCC, 0xCC, 0xCC, 0xCC, 0x00 }, "xxx?xxxxxx?xxxxxx????x????xxxx?xxxxx????xxxxx????x", "Sven-5.25");
		const auto SCR_UpdateScreen = new CIntelligentPattern({ 0x83, 0xEC, 0x44, 0xA1, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0xC4, 0x89, 0x44, 0x24, 0xCC, 0x83, 0x3D, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, 0x0F, 0x85, 0xCC, 0xCC, 0xCC, 0xCC }, "xxxx????xxxxx?xx????xxx????", "Sven-5.25");
		const auto SPR_Set = new CIntelligentPattern({ 0x8B, 0x44, 0x24, 0xCC, 0x83, 0xC0, 0xFF, 0x78, 0xCC, 0x3B, 0x05, 0xCC, 0xCC, 0xCC, 0xCC, 0x7D, 0xCC, 0x8D, 0x0C, 0xCC, 0xA1, 0xCC, 0xCC, 0xCC, 0xCC, 0x8D, 0x04, 0xCC, 0x85, 0xC0, 0x74, 0xCC, 0x8B, 0x00, 0x85, 0xC0, 0x74, 0xCC, 0x8B, 0x80, 0xCC, 0xCC, 0xCC, 0xCC, 0xA3, 0xCC, 0xCC, 0xCC, 0xCC }, "xxx?xxxx?xx????x?xx?x????xx?xxx?xxxxx?xx????x????", "Sven-5.25");
		const auto Draw_FillRGBA = new CIntelligentPattern({ 0x56, 0x68, 0xE1, 0x0D, 0x00, 0x00, 0xFF, 0x15, 0xCC, 0xCC, 0xCC, 0xCC, 0x68, 0xE2, 0x0B, 0x00, 0x00, 0xFF, 0x15, 0xCC, 0xCC, 0xCC, 0xCC, 0xD9, 0x05, 0xCC, 0xCC, 0xCC, 0xCC, 0x51, 0xD9, 0x1C, 0x24, 0x68, 0x00, 0x22, 0x00, 0x00, 0x68, 0x00, 0x23, 0x00, 0x00, 0xFF, 0x15, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x01 },  "xxxxxxxx????xxxxxxx????xx????xxxxxxxxxxxxxxxx????xx", "Sven-5.25");
		const auto Test = new CIntelligentPattern("68 30 A0 52 5A CC ?? ?? ?? ??", "Eblanium");
	}
	namespace client {
		const auto ScaleColors = new CIntelligentPattern({ 
			//Sven-5.25
			//66 0F 6E 4C 24 ?? 8B 4C 24
			{0x66, 0x0F, 0x6E, 0x4C, 0x24, 0xCC, 0x8B, 0x4C, 0x24},
			//Sven-8458
			//DB 44 24 ?? 56 8B 74 24 ??
			{0xDB, 0x44, 0x24, 0xCC, 0x56, 0x8B, 0x74, 0x24, 0xCC} }, { "xxxxx?xxx", "xxx?xxxx?" }, 
			{ "Sven-5.25", "Sven-8458" });
		const auto SMR_StudioRenderModel = new CIntelligentPattern(
			//Sven-5.25
			//83 EC 44 A1 ?? ?? ?? ?? 33 C4 89 44 24 ?? 53 55
			{ 0x83, 0xEC, 0x44, 0xA1, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0xC4, 0x89, 0x44, 0x24, 0xCC, 0x53, 0x55 }, "xxxx????xxxxx?xx", "Sven-5.25");

	}
}

#endif //PATTERNS_HPP_GUARD

#undef PATTERNS_HPP_RECURSE_GUARD
#endif //PATTERNS_HPP_RECURSE_GUARD
